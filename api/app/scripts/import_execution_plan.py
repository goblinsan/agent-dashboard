from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable

from sqlalchemy.orm import Session

from app.db import SessionLocal
from app.models import Milestone, Phase, Project, ProjectPersona, Persona, Task

PLAN = {
    "project": {
        "name": "Multi-Agent Project Dashboard",
        "goal": "Reach a usable vertical slice that lets us plan this project inside the product",
        "direction": "Agent-assisted execution planning",
    },
    "personas": [
        {
            "key": "lead_engineer",
            "name": "Lead Engineer",
            "description": "Leads implementation of complex backend and infrastructure tasks",
            "maximum_active_tasks": 3,
            "limit_per_agent": 2,
        },
        {
            "key": "product_manager",
            "name": "Product Manager",
            "description": "Owns prioritisation and backlog grooming",
            "maximum_active_tasks": 2,
            "limit_per_agent": 1,
        },
        {
            "key": "designer",
            "name": "Product Designer",
            "description": "Defines user experience flows and visual states",
            "maximum_active_tasks": 1,
            "limit_per_agent": 1,
        },
    ],
    "milestones": [
        {
            "name": "MVP0 - Vertical Slice",
            "description": "Vertical slice covering infra, API, web, roll-ups, and dogfooding",
            "phases": [
                {
                    "name": "Phase A - Infra & API skeleton (Day 1-2)",
                    "tasks": [
                        {"title": "Docker compose (Postgres, Redis, API, Web)", "status": "done"},
                        {
                            "title": "Alembic migration for projects, milestones, phases, tasks",
                            "status": "done",
                        },
                        {
                            "title": "Endpoints: .well-known/schemas, POST/GET projects, milestones, tasks",
                            "status": "done"},
                        {"title": "Optimistic locking on PATCH /v1/tasks/:id", "status": "done"},
                    ],
                },
                {
                    "name": "Phase B - Web UI skeleton (Day 2-3)",
                    "tasks": [
                        {"title": "Dashboard list of projects", "status": "done"},
                        {"title": "Create project form (barebones)", "status": "done"},
                        {"title": "Task list under milestone; inline add task", "status": "done"},
                    ],
                },
                {
                    "name": "Phase C - Roll-ups & NSA stubs (Day 3-4)",
                    "tasks": [
                        {"title": "/v1/projects/:id/status computed with remaining hours", "status": "done"},
                        {"title": "/v1/projects/:id/next-action returns top 3 placeholders", "status": "done"},
                    ],
                },
                {
                    "name": "Phase D - Dogfood & Iterate (Day 4-5)",
                    "tasks": [
                        {"title": "Create this project in the tool and import this plan as tasks", "status": "done"},
                        {"title": "Daily status summary generated by API and shown on dashboard", "status": "done"},
                    ],
                },
            ],
        },
        {
            "name": "MVP1 - Usability",
            "description": "Follow-on work for personas, bug tracker, and activity view",
            "phases": [
                {
                    "name": "Future Enhancements",
                    "tasks": [
                        {"title": "Personas registry + limits (read-only UI)", "status": "in_progress"},
                        {"title": "Basic bug tracker (CRUD, link to tasks)", "status": "not_started"},
                        {"title": "Event log (append-only) + activity view", "status": "not_started"},
                    ],
                }
            ],
        },
    ],
}


@dataclass
class UpsertResult:
    created: bool
    obj: object


def _get_or_create_project(session: Session) -> Project:
    payload = PLAN["project"]
    project = session.query(Project).filter(Project.name == payload["name"]).one_or_none()
    if project:
        project.goal = payload["goal"]
        project.direction = payload["direction"]
        return project

    project = Project(name=payload["name"], goal=payload["goal"], direction=payload["direction"])
    session.add(project)
    session.flush()
    return project


def _ensure_personas(session: Session) -> None:
    for payload in PLAN["personas"]:
        persona = session.get(Persona, payload["key"])
        if persona is None:
            persona = Persona(key=payload["key"], name=payload["name"])
            session.add(persona)
        persona.description = payload.get("description")
        persona.maximum_active_tasks = payload.get("maximum_active_tasks")


def _assign_personas_to_project(session: Session, project: Project) -> None:
    for payload in PLAN["personas"]:
        link = (
            session.query(ProjectPersona)
            .filter(
                ProjectPersona.project_id == project.id,
                ProjectPersona.persona_key == payload["key"],
            )
            .one_or_none()
        )
        if link is None:
            link = ProjectPersona(
                project_id=project.id,
                persona_key=payload["key"],
            )
            session.add(link)
        link.limit_per_agent = payload.get("limit_per_agent")


def _get_or_create_milestone(session: Session, project: Project, name: str, description: str) -> Milestone:
    milestone = (
        session.query(Milestone)
        .filter(Milestone.project_id == project.id, Milestone.name == name)
        .one_or_none()
    )
    if milestone:
        milestone.description = description
        return milestone

    milestone = Milestone(project_id=project.id, name=name, description=description)
    session.add(milestone)
    session.flush()
    return milestone


def _get_or_create_phase(session: Session, milestone: Milestone, name: str) -> Phase:
    phase = (
        session.query(Phase)
        .filter(Phase.milestone_id == milestone.id, Phase.name == name)
        .one_or_none()
    )
    if phase:
        return phase

    phase = Phase(milestone_id=milestone.id, name=name)
    session.add(phase)
    session.flush()
    return phase


def _upsert_task(session: Session, milestone: Milestone, phase: Phase, title: str, status: str) -> Task:
    task = (
        session.query(Task)
        .filter(Task.milestone_id == milestone.id, Task.title == title)
        .one_or_none()
    )

    estimate = 2.0
    spent = estimate if status == "done" else 0.0

    if task:
        task.phase_id = phase.id
        task.status = status
        task.effort_estimate = estimate
        task.effort_spent = spent
        task.lock_version += 1
        return task

    task = Task(
        milestone_id=milestone.id,
        phase_id=phase.id,
        title=title,
        status=status,
        effort_estimate=estimate,
        effort_spent=spent,
    )
    session.add(task)
    session.flush()
    return task


def import_execution_plan() -> None:
    session = SessionLocal()
    try:
        project = _get_or_create_project(session)
        _ensure_personas(session)
        _assign_personas_to_project(session, project)

        for milestone_payload in PLAN["milestones"]:
            milestone = _get_or_create_milestone(
                session,
                project,
                name=milestone_payload["name"],
                description=milestone_payload.get("description", ""),
            )
            for phase_payload in milestone_payload.get("phases", []):
                phase = _get_or_create_phase(session, milestone, name=phase_payload["name"])
                for task_payload in phase_payload.get("tasks", []):
                    _upsert_task(
                        session,
                        milestone,
                        phase,
                        title=task_payload["title"],
                        status=task_payload.get("status", "not_started"),
                    )
        session.commit()
        print("Execution plan imported successfully.")
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


if __name__ == "__main__":
    import_execution_plan()
